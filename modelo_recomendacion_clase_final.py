# -*- coding: utf-8 -*-
"""Modelo_Recomendacion_Clase_FINAL

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13nvQY__hy25-R3L4LUqZ-mEKOZNNlKz9
"""

from google.cloud import bigquery
from google.oauth2 import service_account

from google.colab import drive    #Estas líneas de código se utilizan para montar el sistema de archivos de Google Drive en Google Colab.
drive.mount('/content/drive')

import pandas as pd
import numpy as np
import seaborn as sns
import statsmodels.api as sm
from warnings import filterwarnings
import os
from scipy.spatial.distance import pdist, squareform

credentials = service_account.Credentials.from_service_account_file("/content/drive/MyDrive/Gestion_de_Datos/Entrega_Proyecto/datos_clave.json", scopes=["https://www.googleapis.com/auth/cloud-platform"])

project_id = 'proyecto-gestion-datos'
client = bigquery.Client(credentials= credentials,project=project_id)

sql = """
   SELECT * FROM proyecto-gestion-datos.tablas_proyecto.tracks 
"""
tracks = client.query(sql).to_dataframe()
tracks.head(1)



"""Dado que por capacidad de procesamiento, la maquina no puede hacer el calculo de recomendacion en toda la tabla. Se decide usar una muestra del 6%."""



tracks_sample = tracks.sample(frac=0.06
                              ,replace=False, random_state=13)

sql = """
   SELECT * FROM proyecto-gestion-datos.tablas_proyecto.artists_mod 
"""
artists = client.query(sql).to_dataframe()
artists.head(1)

DTF = tracks_sample.merge(artists.loc[:,["id","genres"]], on='id', how='left').reset_index()
DTF

DTF["Song_popularity_bin"]= pd.cut(DTF["popularity"],5, labels=["low","low_med", "medium","med_high", "High"])

DTF[DTF.genres!=np.NaN,:].shape

"""```
# Tiene formato de código
```

Dado que al hacer un join por la columna id, no hay datos en comun entre la tabla tracks y artist ... La caracteristica genero no sera tenida en cuenta.

Para esta estructura de datos, la mejor metodologia para implementar un sistema de recomendacion es un "Item Recomendation Filter".
"""

TRACKS_TRAIN = DTF.loc[:,['name', 'popularity', 'duration_ms', 'explicit', 'artists', 'danceability', 'energy', 'key',
       'loudness', 'mode', 'speechiness', 'acousticness', 'instrumentalness',
       'liveness', 'valence', 'tempo', 'time_signature',"Song_popularity_bin"]]

one_hot_song_popularity = pd.get_dummies(TRACKS_TRAIN['Song_popularity_bin'])
TRACKS_TRAIN = TRACKS_TRAIN.drop('Song_popularity_bin',axis = 1)
TRACKS_TRAIN= TRACKS_TRAIN.join(one_hot_song_popularity)
TRACKS_TRAIN.tail(1)

TRACKS_TRAIN.head(2)



"""Se programa el sistema de recomendacion como una Clase, con los siguientes parametros:

- df : Tabla con data de entrenamiento y nombre de las canciones y artista asociado.

- metric : Metodologia con la cual se va a calcular la similaridad entre canciones.

- Song : Cancion a Evaluar.

- top : El top de canciones mas similares a la cancion evaluada.
"""



class Recomendation_engine:
  def __init__(self, df, metric="mahalanobis"):
    self.df = df
    self.metric = metric

  def similarity(self):

    df = self.df
    
    DT_TRAIN = df.loc[:,[ 'popularity', 'duration_ms', 'explicit', 'danceability', 'energy', 'key',
       'loudness', 'mode', 'speechiness', 'acousticness', 'instrumentalness',
       'liveness', 'valence', 'tempo', 'time_signature',"low"	,"low_med",	"medium",	"med_high",	"High"]]

    distances = pdist(DT_TRAIN, metric=self.metric)
    dist_matrix = squareform(distances)
     
    return(dist_matrix)
  def Top_Recomendation(self,Song="YearZero",top=5):

    df = self.df
    df['name']=df['name'].apply(str. lower)
    dist_matrix = self.similarity()
    Song = Song.lower()
    INDEX = df[df.name == Song].index[0]
    d = {'SONG_NAME': df["name"],"Artists":df["artists"],'PROXYMITY': dist_matrix[INDEX]}
    AA = pd.DataFrame(data=d)
    AA=AA.sort_values(by='PROXYMITY', ascending=True)
    BB= AA[0:top+1]
    
    return(BB)



"""Para que los resultados puedan ser consumidos, se aloja en una tabla todos los resultados posibles del sistema de recomentacion (solo se coloca el top 5 de las canciones mas parecidas bajo una distancia de "mahalanobis")."""

DT_TRAIN = TRACKS_TRAIN.loc[:,[ "name","artists",'popularity']]

p1 = Recomendation_engine(df =TRACKS_TRAIN ,metric= "mahalanobis")
AA=p1.similarity()

Recomendation_DATA_FRAME = pd.DataFrame()

for i in range(len(AA[0])):
  song_name= np.repeat(DT_TRAIN["name"][i], len(AA[i]))
  artist_name= np.repeat(DT_TRAIN["artists"][i], len(AA[i]))
  recomendation_song= DT_TRAIN["name"]
  recomendation_score= AA[i]
  d = {'SONG_NAME': song_name,"Artists":artist_name,"Recomendation_Song":recomendation_song,'PROXYMITY': recomendation_score}
  AP = pd.DataFrame(data=d)
  AP = AP.sort_values(by=['PROXYMITY'], ascending=True)
  AP = AP[1:6]
  Recomendation_DATA_FRAME = Recomendation_DATA_FRAME.append(AP)

Recomendation_DATA_FRAME



# Configuramos los campos que tendra la tabla en BQ.

job_config_tracks = bigquery.LoadJobConfig(
    schema=[
        # Supported datatypes: https://cloud.google.com/bigquery/docs/reference/standard-sql/data-types
        bigquery.SchemaField("SONG_NAME", bigquery.enums.SqlTypeNames.STRING),
        bigquery.SchemaField("Artists", bigquery.enums.SqlTypeNames.STRING),
        bigquery.SchemaField("Recomendation_Song", bigquery.enums.SqlTypeNames.STRING),
        bigquery.SchemaField("PROXYMITY", bigquery.enums.SqlTypeNames.FLOAT64)
  
    ],
    # Drod and re-create table, if exist
    write_disposition="WRITE_TRUNCATE"
)

BQ_TABLE_NAME_tracks = f"tablas_proyecto.resultado_recomendacion"
job = client.load_table_from_dataframe(Recomendation_DATA_FRAME, BQ_TABLE_NAME_tracks, job_config=job_config_tracks)
job.result()











"""Se evaluan resultados con la metrica Coseno, para 3 canciones aleatorias:

* Year Zero  de Andy Moor, Orkidea.
* Revolviendo de Los de Marras.
* Live Wire de Mötley Crüe.
"""

p1 = Recomendation_engine(df =TRACKS_TRAIN ,metric= "cosine")
p1.Top_Recomendation(Song="YearZero")

p1 = Recomendation_engine(df =TRACKS_TRAIN ,metric= "cosine")
p1.Top_Recomendation(Song="Revolviendo")

p1 = Recomendation_engine(df =TRACKS_TRAIN ,metric= "cosine")
p1.Top_Recomendation(Song="Live Wire")



"""Ahora bien, se hace evaluacion de las mismas canciones pero bajo la distancia de "mahalanobis", la cual tiene en cuenta correlaciones lineales."""



p1 = Recomendation_engine(df =TRACKS_TRAIN ,metric= "mahalanobis")
p1.Top_Recomendation(Song="YearZero")

p1.Top_Recomendation(Song="Revolviendo")

p1.Top_Recomendation(Song="Live Wire")



"""Distancia Euclideana:"""

p1 = Recomendation_engine(df =TRACKS_TRAIN ,metric= "euclidean")
p1.Top_Recomendation(Song="YearZero")

p1 = Recomendation_engine(df =TRACKS_TRAIN ,metric= "euclidean")
p1.Top_Recomendation(Song="Revolviendo")

p1 = Recomendation_engine(df =TRACKS_TRAIN ,metric= "euclidean")
p1.Top_Recomendation(Song="Live Wire")



"""Distancia Jaccard:"""

p1 = Recomendation_engine(df =TRACKS_TRAIN ,metric= "jaccard")
p1.Top_Recomendation(Song="YearZero")

p1 = Recomendation_engine(df =TRACKS_TRAIN ,metric= "jaccard")
p1.Top_Recomendation(Song="Revolviendo")

p1 = Recomendation_engine(df =TRACKS_TRAIN ,metric= "jaccard")
p1.Top_Recomendation(Song="Live Wire")

